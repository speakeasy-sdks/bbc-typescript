/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as operations from "../models/operations";

export enum ListAvailabilityAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListBroadcastsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListGroupsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListImagesAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListItemsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListMasterbrandsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListPeopleAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListPipsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetProgrammeAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListProgrammesAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListPromotionsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListSchedulesAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListServicesAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum ListVersionsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export class Feeds extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Discover details of on-demand availability for programmes and their versions
     *
     * @remarks
     * Discover details of on-demand availability for programmes and their versions
     */
    async listAvailability(
        request: operations.ListAvailabilityRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListAvailabilityAcceptEnum }
    ): Promise<operations.ListAvailabilityResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListAvailabilityRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/availabilities")();

        const query$ = [
            enc$.encodeForm("availability", payload$.availability, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("debug", payload$.debug, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("descendants_of", payload$.descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("media_set", payload$.media_set, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("territory", payload$.territory, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listAvailability",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListAvailabilityResponse>()
            .json(200, operations.ListAvailabilityResponse$, { key: "nitro" })
            .bytes(200, operations.ListAvailabilityResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListAvailabilityResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListAvailabilityResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts
     *
     * @remarks
     * Fetch metadata about linear Broadcasts and Services, allowing the generation of Television and Radio schedules and other datasets for broadcast items. Use /schedules instead of this feed as it is more efficient. Broadcasts will be deprecated in the future.
     */
    async listBroadcasts(
        request: operations.ListBroadcastsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListBroadcastsAcceptEnum }
    ): Promise<operations.ListBroadcastsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListBroadcastsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/broadcasts")();

        const query$ = [
            enc$.encodeForm("authority", payload$.authority, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("descendants_of", payload$.descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("end_from", payload$.end_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("end_to", payload$.end_to, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("format", payload$.format, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("genre", payload$.genre, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("id", payload$.id, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("item", payload$.item, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("people", payload$.people, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("schedule_day", payload$.schedule_day, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("schedule_day_from", payload$.schedule_day_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("schedule_day_to", payload$.schedule_day_to, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("service_master_brand", payload$.service_master_brand, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("sid", payload$.sid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("start_from", payload$.start_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("start_to", payload$.start_to, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("version", payload$.version, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listBroadcasts",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListBroadcastsResponse>()
            .json(200, operations.ListBroadcastsResponse$, { key: "nitro" })
            .bytes(200, operations.ListBroadcastsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListBroadcastsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListBroadcastsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Find metadata for curated groups: seasons, collections, galleries or franchises
     *
     * @remarks
     * Long-lived curated collections of programmes and more, including Collections, Seasons, Franchises and Galleries
     */
    async listGroups(
        request: operations.ListGroupsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListGroupsAcceptEnum }
    ): Promise<operations.ListGroupsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListGroupsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/groups")();

        const query$ = [
            enc$.encodeForm("embargoed", payload$.embargoed, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("for_descendants_of", payload$.for_descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("for_programme", payload$.for_programme, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("group", payload$.group, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("group_type", payload$.group_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("member", payload$.member, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listGroups",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListGroupsResponse>()
            .json(200, operations.ListGroupsResponse$, { key: "nitro" })
            .bytes(200, operations.ListGroupsResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListGroupsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListGroupsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Find metadata for images
     *
     * @remarks
     * Find metadata for images, particularly those in galleries
     */
    async listImages(
        request: operations.ListImagesRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListImagesAcceptEnum }
    ): Promise<operations.ListImagesResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListImagesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/images")();

        const query$ = [
            enc$.encodeForm("embargoed", payload$.embargoed, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("group", payload$.group, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("image_type", payload$.image_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("is_alternate_image_for", payload$.is_alternate_image_for, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("is_image_for", payload$.is_image_for, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listImages",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListImagesResponse>()
            .json(200, operations.ListImagesResponse$, { key: "nitro" })
            .bytes(200, operations.ListImagesResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListImagesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListImagesResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Look inside programmes to find segments: chapters, tracks and more
     *
     * @remarks
     * Look inside programmes to find segments: chapters, tracks and more
     */
    async listItems(
        request: operations.ListItemsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListItemsAcceptEnum }
    ): Promise<operations.ListItemsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListItemsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/items")();

        const query$ = [
            enc$.encodeForm("authority", payload$.authority, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("id", payload$.id, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("id_type", payload$.id_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("item_type", payload$.item_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("people", payload$.people, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("programme", payload$.programme, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("segment_event", payload$.segment_event, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listItems",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListItemsResponse>()
            .json(200, operations.ListItemsResponse$, { key: "nitro" })
            .bytes(200, operations.ListItemsResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListItemsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListItemsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * List all Master Brands
     *
     * @remarks
     * List all Master Brands
     */
    async listMasterbrands(
        request: operations.ListMasterbrandsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListMasterbrandsAcceptEnum }
    ): Promise<operations.ListMasterbrandsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListMasterbrandsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/master_brands")();

        const query$ = [
            enc$.encodeForm("mid", payload$.mid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listMasterbrands",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListMasterbrandsResponse>()
            .json(200, operations.ListMasterbrandsResponse$, { key: "nitro" })
            .bytes(200, operations.ListMasterbrandsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListMasterbrandsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListMasterbrandsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Find the people behind and in programmes: cast, crew, guests and more
     *
     * @remarks
     * The People feed allows you to search for the people and groups that contribute to programmes. This is the starting point for cast and crew credits, as well as finding contributors using external IDs (such as Wikipedia URLs)
     */
    async listPeople(
        request: operations.ListPeopleRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListPeopleAcceptEnum }
    ): Promise<operations.ListPeopleResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListPeopleRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/people")();

        const query$ = [
            enc$.encodeForm("authority", payload$.authority, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("has_external_id", payload$.has_external_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("id", payload$.id, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("id_type", payload$.id_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("programme", payload$.programme, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listPeople",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListPeopleResponse>()
            .json(200, operations.ListPeopleResponse$, { key: "nitro" })
            .bytes(200, operations.ListPeopleResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListPeopleResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListPeopleResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Look inside pips entities
     *
     * @remarks
     * Look inside pips entities
     */
    async listPips(
        page?: number | undefined,
        pageSize?: number | undefined,
        q?: string | undefined,
        options?: RequestOptions & { acceptHeaderOverride?: ListPipsAcceptEnum }
    ): Promise<operations.ListPipsResponse> {
        const input$: operations.ListPipsRequest = {
            page: page,
            pageSize: pageSize,
            q: q,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListPipsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/pips")();

        const query$ = [
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listPips",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListPipsResponse>()
            .json(200, operations.ListPipsResponse$, { key: "nitro" })
            .bytes(200, operations.ListPipsResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListPipsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListPipsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Exposes programme information for a single pid
     *
     * @remarks
     * Exposes programme information for a single pid
     */
    async getProgramme(
        page?: number | undefined,
        pageSize?: number | undefined,
        partnerPid?: string | undefined,
        pid?: string | undefined,
        options?: RequestOptions & { acceptHeaderOverride?: GetProgrammeAcceptEnum }
    ): Promise<operations.ListProgrammeDetailsResponse> {
        const input$: operations.ListProgrammeDetailsRequest = {
            page: page,
            pageSize: pageSize,
            partnerPid: partnerPid,
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListProgrammeDetailsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/programme_details")();

        const query$ = [
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listProgrammeDetails",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListProgrammeDetailsResponse>()
            .json(200, operations.ListProgrammeDetailsResponse$, { key: "nitro" })
            .bytes(200, operations.ListProgrammeDetailsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListProgrammeDetailsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListProgrammeDetailsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Start here for programmes metadata: Brands, Series, Episodes and Clips
     *
     * @remarks
     * Fetch metadata about Programmes (brands, series, episodes, clips). By applying different filter restrictions this feed can be used in many ways, for example to retrieve all series belonging to a brand, all the episodes and/or clips for a specific series, or any TLEO objects for a masterbrand. Other filters permit restricting to specific formats and/or genres, and you can request specific versions (for example Signed or Audio-Described). Parameters may be combined in any way suitable for your application.
     */
    async listProgrammes(
        request: operations.ListProgrammesRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListProgrammesAcceptEnum }
    ): Promise<operations.ListProgrammesResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListProgrammesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/programmes")();

        const query$ = [
            enc$.encodeForm("audio_described", payload$.audio_described, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("availability", payload$.availability, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("availability_entity_type", payload$.availability_entity_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("availability_from", payload$.availability_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("availability_type", payload$.availability_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("children_of", payload$.children_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("descendants_of", payload$.descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("duration", payload$.duration, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("embargoed", payload$.embargoed, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("entity_type", payload$.entity_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("format", payload$.format, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("genre", payload$.genre, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("group", payload$.group, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("initial_letter", payload$.initial_letter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("initial_letter_end", payload$.initial_letter_end, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("initial_letter_start", payload$.initial_letter_start, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("initial_letter_strict", payload$.initial_letter_strict, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("item", payload$.item, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("master_brand", payload$.master_brand, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("media_set", payload$.media_set, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("media_type", payload$.media_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("payment_type", payload$.payment_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("people", payload$.people, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("promoted_for", payload$.promoted_for, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("signed", payload$.signed, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("tag_name", payload$.tag_name, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("tag_scheme", payload$.tag_scheme, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("tleo", payload$.tleo, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("version", payload$.version, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listProgrammes",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListProgrammesResponse>()
            .json(200, operations.ListProgrammesResponse$, { key: "nitro" })
            .bytes(200, operations.ListProgrammesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListProgrammesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListProgrammesResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Discover metadata for content promotions
     *
     * @remarks
     * Details of short-term editorially curated "promotions", for instance those programmes featured on iPlayer today
     */
    async listPromotions(
        request: operations.ListPromotionsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListPromotionsAcceptEnum }
    ): Promise<operations.ListPromotionsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListPromotionsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/promotions")();

        const query$ = [
            enc$.encodeForm("context", payload$.context, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("promoted_by", payload$.promoted_by, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("promoted_for", payload$.promoted_for, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("status", payload$.status, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listPromotions",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListPromotionsResponse>()
            .json(200, operations.ListPromotionsResponse$, { key: "nitro" })
            .bytes(200, operations.ListPromotionsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListPromotionsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListPromotionsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Build schedules and find metadata for TV and radio broadcasts and webcasts
     *
     * @remarks
     * Dates, Times, Schedules: when and where are programmes being shown?
     */
    async listSchedules(
        request: operations.ListSchedulesRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListSchedulesAcceptEnum }
    ): Promise<operations.ListSchedulesResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListSchedulesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/schedules")();

        const query$ = [
            enc$.encodeForm("authority", payload$.authority, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("descendants_of", payload$.descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("end_from", payload$.end_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("end_to", payload$.end_to, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("format", payload$.format, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("genre", payload$.genre, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("group", payload$.group, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("id", payload$.id, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("id_type", payload$.id_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("item", payload$.item, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("mixin", payload$.mixin, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("people", payload$.people, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("repeat", payload$.repeat, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("schedule_day", payload$.schedule_day, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("schedule_day_from", payload$.schedule_day_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("schedule_day_to", payload$.schedule_day_to, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("service_master_brand", payload$.service_master_brand, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("sid", payload$.sid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort", payload$.sort, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("sort_direction", payload$.sort_direction, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("start_from", payload$.start_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("start_to", payload$.start_to, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("version", payload$.version, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listSchedules",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListSchedulesResponse>()
            .json(200, operations.ListSchedulesResponse$, { key: "nitro" })
            .bytes(200, operations.ListSchedulesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListSchedulesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListSchedulesResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Information about the linear services used for broadcast transmissions
     *
     * @remarks
     * The services feed exposes the linear broadcast "services" from PIPs. These are the actual services which broadcast programmes (eg bbc_one_oxford is the service for BBC One in Oxford).
     */
    async listServices(
        request: operations.ListServicesRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListServicesAcceptEnum }
    ): Promise<operations.ListServicesResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListServicesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/services")();

        const query$ = [
            enc$.encodeForm("end_from", payload$.end_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("end_to", payload$.end_to, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("mid", payload$.mid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("q", payload$.q, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("service_type", payload$.service_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("sid", payload$.sid, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("start_from", payload$.start_from, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("start_to", payload$.start_to, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listServices",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListServicesResponse>()
            .json(200, operations.ListServicesResponse$, { key: "nitro" })
            .bytes(200, operations.ListServicesResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListServicesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListServicesResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Metadata on editorial programme versions: original, signed, audio-described, etc
     *
     * @remarks
     * The versions feed exposes editorial "Versions" of programmes. These are concepts used to capture different presentations of an overall programme: for example, versions of a programme may include one with sign language, one with audio description, one edited for content and more. Versions are also important to understand for broadcasts: a linear broadcast or an ondemand is always of a specific version, not merely of a programme.
     */
    async listVersions(
        request: operations.ListVersionsRequest,
        options?: RequestOptions & { acceptHeaderOverride?: ListVersionsAcceptEnum }
    ): Promise<operations.ListVersionsResponse> {
        const input$ = typeof request === "undefined" ? {} : request;
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ListVersionsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/versions")();

        const query$ = [
            enc$.encodeForm("availability", payload$.availability, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("descendants_of", payload$.descendants_of, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("embargoed", payload$.embargoed, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("media_set", payload$.media_set, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("page", payload$.page, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("page_size", payload$.page_size, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_id", payload$.partner_id, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("partner_pid", payload$.partner_pid, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("payment_type", payload$.payment_type, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("pid", payload$.pid, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "listVersions",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.ListVersionsResponse>()
            .json(200, operations.ListVersionsResponse$, { key: "nitro" })
            .bytes(200, operations.ListVersionsResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .bytes("default", operations.ListVersionsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .json("default", operations.ListVersionsResponse$, { key: "ErrorModel" })
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }
}
