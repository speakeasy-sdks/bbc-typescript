/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as operations from "../models/operations";

export enum GetBrandAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetBrandFranchisesAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetEpisodeAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetAncestorsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetFormatsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetGenreGroupsAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetImageAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetMasterBrandAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export enum GetPromotionAcceptEnum {
    applicationJson = "application/json",
    applicationXml = "application/xml",
}

export class Raw extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Get raw brand
     *
     * @remarks
     * Get raw brand
     */
    async getBrand(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetBrandAcceptEnum }
    ): Promise<operations.GetRawBrandResponse> {
        const input$: operations.GetRawBrandRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawBrandRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/brands/{pid}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_brand",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawBrandResponse>()
            .json(200, operations.GetRawBrandResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawBrandResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw brand franchise
     *
     * @remarks
     * Get raw brand franchises
     */
    async getBrandFranchises(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetBrandFranchisesAcceptEnum }
    ): Promise<operations.GetRawBrandFranchisesResponse> {
        const input$: operations.GetRawBrandFranchisesRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawBrandFranchisesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/brands/{pid}/franchises/")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_brand franchises",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawBrandFranchisesResponse>()
            .json(200, operations.GetRawBrandFranchisesResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawBrandFranchisesResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw episode
     *
     * @remarks
     * Get raw episode
     */
    async getEpisode(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetEpisodeAcceptEnum }
    ): Promise<operations.GetRawEpisodeResponse> {
        const input$: operations.GetRawEpisodeRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawEpisodeRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/episodes/{pid}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_episode",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawEpisodeResponse>()
            .json(200, operations.GetRawEpisodeResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawEpisodeResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw ancestors
     *
     * @remarks
     * Get raw ancestors
     */
    async getAncestors(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetAncestorsAcceptEnum }
    ): Promise<operations.GetRawAncestorsResponse> {
        const input$: operations.GetRawAncestorsRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawAncestorsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/episodes/{pid}/ancestors/")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_ancestors",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawAncestorsResponse>()
            .json(200, operations.GetRawAncestorsResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawAncestorsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw formats
     *
     * @remarks
     * Get raw formats
     */
    async getFormats(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetFormatsAcceptEnum }
    ): Promise<operations.GetRawFormatsResponse> {
        const input$: operations.GetRawFormatsRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawFormatsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/episodes/{pid}/formats/")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_formats",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawFormatsResponse>()
            .json(200, operations.GetRawFormatsResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawFormatsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw genre groups
     *
     * @remarks
     * Get raw genre groups
     */
    async getGenreGroups(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetGenreGroupsAcceptEnum }
    ): Promise<operations.GetRawGenreGroupsResponse> {
        const input$: operations.GetRawGenreGroupsRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawGenreGroupsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/episodes/{pid}/genre_groups/")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_genre_groups",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawGenreGroupsResponse>()
            .json(200, operations.GetRawGenreGroupsResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawGenreGroupsResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw image
     *
     * @remarks
     * Get raw image
     */
    async getImage(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetImageAcceptEnum }
    ): Promise<operations.GetRawImageResponse> {
        const input$: operations.GetRawImageRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawImageRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/images/{pid}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_image",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawImageResponse>()
            .json(200, operations.GetRawImageResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawImageResponse$, { ctype: "application/xml", key: "Body" })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw masterbrand
     *
     * @remarks
     * Get raw masterbrand
     */
    async getMasterBrand(
        mbid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetMasterBrandAcceptEnum }
    ): Promise<operations.GetRawMasterbrandResponse> {
        const input$: operations.GetRawMasterbrandRequest = {
            mbid: mbid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawMasterbrandRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            mbid: enc$.encodeSimple("mbid", payload$.mbid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/master_brands/{mbid}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_masterbrand",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawMasterbrandResponse>()
            .json(200, operations.GetRawMasterbrandResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawMasterbrandResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Get raw promotion
     *
     * @remarks
     * Get raw promotion
     */
    async getPromotion(
        pid: string,
        options?: RequestOptions & { acceptHeaderOverride?: GetPromotionAcceptEnum }
    ): Promise<operations.GetRawPromotionResponse> {
        const input$: operations.GetRawPromotionRequest = {
            pid: pid,
        };
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, application/xml;q=0";
        headers$.set("Accept", accept);

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GetRawPromotionRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pid: enc$.encodeSimple("pid", payload$.pid, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/v1/promotions/{pid}")(pathParams$);

        const query$ = "";

        let security$;
        if (typeof this.options$.apiKey === "function") {
            security$ = { apiKey: await this.options$.apiKey() };
        } else if (this.options$.apiKey) {
            security$ = { apiKey: this.options$.apiKey };
        } else {
            security$ = {};
        }
        const context = {
            operationID: "Get_Raw_promotion",
            oAuth2Scopes: [],
            securitySource: this.options$.apiKey,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.GetRawPromotionResponse>()
            .json(200, operations.GetRawPromotionResponse$, { key: "nitro" })
            .bytes(200, operations.GetRawPromotionResponse$, {
                ctype: "application/xml",
                key: "Body",
            })
            .fail(["4XX", "5XX"])
            .match(response, request$, { extraFields: responseFields$ });

        return result$;
    }
}
